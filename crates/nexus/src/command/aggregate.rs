use super::handler::{AggregateCommandHandler, CommandHandlerResponse};
use crate::{Command, DomainEvent};
use std::{fmt::Debug, hash::Hash};
use thiserror::Error as ThisError;

/// # `AggregateState`
pub trait AggregateState: Default + Send + Sync + Debug + 'static {
    /// Specific type of Domain Event this state reacts to.
    type Event: DomainEvent;

    /// Mutates the state based on a receieved event.
    /// This is the core of state reconstruction in Event Sourcing.
    /// It should *NOT* contain complex logic or validation. just state mutation.
    fn apply(&mut self, event: &Self::Event);
}

/// Marker trait to define the component types of a specific Aggregate kind.
/// Implement this on a distinct type (often a unit struct) for each aggregate.
pub trait AggregateType: Send + Sync + Debug + Copy + Clone + 'static {
    /// The type used to uniquely identify this aggregate instance.
    type Id: Send + Sync + Debug + Hash + Eq + 'static + Clone;
    /// The specific type of Domain Event associated with this aggregate.
    type Event: DomainEvent<Id = Self::Id> + PartialEq;
    /// The specific type representing the internal state data.
    /// Crucially links the State's Event type to the AggregateType's Event type.
    type State: AggregateState<Event = Self::Event>;
}

/// Provides a standard interface for accessing aggregate properties.
/// Implemented by `AggregateRoot`.
pub trait Aggregate: Debug + Send + Sync + 'static {
    type Id: Send + Sync + Debug + Hash + Eq + 'static + Clone;
    type Event: DomainEvent<Id = Self::Id> + PartialEq;
    type State: AggregateState<Event = Self::Event>;

    fn id(&self) -> &Self::Id;
    /// Returns the version loaded from the store (basis for concurrency checks).
    fn version(&self) -> u64;
    fn state(&self) -> &Self::State;
    /// Takes ownership of newly generated events for saving.
    fn take_uncommitted_events(&mut self) -> Vec<Self::Event>;
}

#[derive(Debug, ThisError, PartialEq)]
pub enum AggregateLoadError<Id>
where
    Id: Debug,
{
    #[error(
        "Event integrity error: Loaded event with mismatched aggregate ID. Expected '{expected_id:?}', found in event: '{event_aggregate_id:?}'."
    )]
    MismatchedAggregateId {
        expected_id: Id,
        event_aggregate_id: Id,
    },
}

/// Concrete implementation managing an aggregate's state based on events.
/// Generic over the aggregate definition provided by `AT: AggregateType`.
#[derive(Debug)]
pub struct AggregateRoot<AT: AggregateType> {
    id: AT::Id,
    state: AT::State,
    /// The version loaded from the event store (number of events historically applied).
    version: u64,
    /// Events generated by the last command execution, not yet persisted.
    uncommitted_events: Vec<AT::Event>,
}

impl<AT> Aggregate for AggregateRoot<AT>
where
    AT: AggregateType,
{
    type Id = AT::Id;
    type Event = AT::Event;
    type State = AT::State;

    fn id(&self) -> &Self::Id {
        &self.id
    }

    fn state(&self) -> &Self::State {
        &self.state
    }

    fn version(&self) -> u64 {
        self.version
    }

    fn take_uncommitted_events(&mut self) -> Vec<Self::Event> {
        std::mem::take(&mut self.uncommitted_events)
    }
}

impl<AT> AggregateRoot<AT>
where
    AT: AggregateType,
{
    /// Creates a new aggregate instance with default state and version 0.
    pub fn new(id: AT::Id) -> Self {
        Self {
            id,
            state: AT::State::default(),
            version: 0,
            uncommitted_events: Vec::new(),
        }
    }

    /// Rehydrates aggregate state by applying historical events.
    pub fn load_from_history(
        id: AT::Id,
        history: impl IntoIterator<Item = AT::Event>,
    ) -> Result<Self, AggregateLoadError<AT::Id>>
    where
        AT::Id: ToString,
    {
        let mut state = AT::State::default();
        let mut version = 0u64;

        for event in history {
            let event_id = event.aggregate_id();
            if event_id != &id {
                return Err(AggregateLoadError::MismatchedAggregateId {
                    expected_id: id,
                    event_aggregate_id: event_id.clone(),
                });
            }

            state.apply(&event);
            version += 1;
        }

        Ok(Self {
            id,
            state,
            version,
            uncommitted_events: Vec::new(),
        })
    }

    /// Gets the effective current version, including uncommitted events.
    /// Useful for repositories implementing optimistic concurrency checks.
    pub fn current_version(&self) -> u64 {
        self.version + self.uncommitted_events.len() as u64
    }

    pub async fn execute<C, Handler, Services>(
        &mut self,
        command: C,
        handler: &Handler,
        services: &Services,
    ) -> Result<C::Result, C::Error>
    where
        C: Command,
        Handler: AggregateCommandHandler<C, Services, AggregateType = AT>,
        Services: Send + Sync + ?Sized,
    {
        let CommandHandlerResponse { events, result } =
            handler.handle(&self.state, command, services).await?;
        for event in &events {
            self.state.apply(event);
        }
        self.uncommitted_events.extend(events);
        Ok(result)
    }
}

#[cfg(test)]
pub mod test {
    use super::{Aggregate, AggregateLoadError, AggregateRoot, AggregateState, AggregateType};
    use crate::command::handler::test::{CreateUser, CreateUserHandler, UserError};
    use crate::{DomainEvent, Message};
    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};

    #[derive(Debug, Default, PartialEq)]
    pub struct UserState {
        email: Option<String>,
        is_active: bool,
        created_at: Option<DateTime<Utc>>,
    }

    impl UserState {
        pub fn new(
            email: Option<String>,
            is_active: bool,
            created_at: Option<DateTime<Utc>>,
        ) -> Self {
            Self {
                email,
                is_active,
                created_at,
            }
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
    pub enum UserDomainEvents {
        UserCreated {
            id: String,
            email: String,
            timestamp: DateTime<Utc>,
        },
        UserActivated {
            id: String,
        },
    }

    impl Message for UserDomainEvents {}

    impl DomainEvent for UserDomainEvents {
        type Id = String;
        fn aggregate_id(&self) -> &Self::Id {
            match self {
                Self::UserActivated { id } => id,
                Self::UserCreated { id, .. } => id,
            }
        }
    }

    impl AggregateState for UserState {
        type Event = UserDomainEvents;

        fn apply(&mut self, event: &Self::Event) {
            match event {
                UserDomainEvents::UserCreated {
                    email, timestamp, ..
                } => {
                    self.email = Some(email.to_string());
                    self.created_at = Some(*timestamp);
                }
                UserDomainEvents::UserActivated { .. } => {
                    if self.created_at.is_some() {
                        self.is_active = true;
                    }
                }
            }
        }
    }

    pub enum EventOrderType {
        Ordered,
        UnOrdered,
    }

    pub fn get_user_events(
        timestamp: Option<DateTime<Utc>>,
        order: EventOrderType,
    ) -> Vec<UserDomainEvents> {
        let user_created = timestamp.map_or_else(
            || UserDomainEvents::UserCreated {
                id: "id".to_string(),
                email: String::from("joel@tixlys.com"),
                timestamp: Utc::now(),
            },
            |t| UserDomainEvents::UserCreated {
                id: "id".to_string(),
                email: String::from("joel@tixlys.com"),
                timestamp: t,
            },
        );
        let user_activated = UserDomainEvents::UserActivated {
            id: "id".to_string(),
        };
        match order {
            EventOrderType::Ordered => vec![user_created, user_activated],
            EventOrderType::UnOrdered => vec![user_activated, user_created],
        }
    }

    #[test]
    fn user_state_default() {
        let user_state = UserState::default();
        assert_eq!(user_state.email, None);
        assert_eq!(user_state.created_at, None);
        assert!(!user_state.is_active);
    }

    #[test]
    fn user_state_apply_created() {
        let mut user_state = UserState::default();
        let timestamp = Utc::now();
        let user_created = UserDomainEvents::UserCreated {
            id: "id".to_string(),
            email: String::from("joel@tixlys.com"),
            timestamp,
        };

        user_state.apply(&user_created);

        assert_eq!(user_state.email, Some(String::from("joel@tixlys.com")));
        assert_eq!(user_state.created_at, Some(timestamp));
    }

    #[test]
    fn user_state_apply_activated() {
        let mut user_state = UserState::default();
        let timestamp = Utc::now();
        for events in get_user_events(Some(timestamp), EventOrderType::Ordered) {
            user_state.apply(&events);
        }
        assert!(user_state.is_active);
    }

    #[test]
    fn user_state_apply_order() {
        let mut user_state = UserState::default();
        let timestamp = Utc::now();
        for events in get_user_events(Some(timestamp), EventOrderType::UnOrdered) {
            user_state.apply(&events);
        }
        assert_eq!(user_state.email, Some(String::from("joel@tixlys.com")));
        assert_eq!(user_state.created_at, Some(timestamp));
        assert!(!user_state.is_active);
    }

    #[test]
    fn user_state_apply_idempotency() {
        let mut user_state = UserState::default();
        let timestamp = Utc::now();
        let user_created = UserDomainEvents::UserCreated {
            id: "id".to_string(),
            email: String::from("joel@tixlys.com"),
            timestamp,
        };
        user_state.apply(&user_created);
        user_state.apply(&user_created);
        user_state.apply(&user_created);
        user_state.apply(&user_created);
        assert_eq!(user_state.email, Some(String::from("joel@tixlys.com")));
        assert_eq!(user_state.created_at, Some(timestamp));
        assert!(!user_state.is_active);
    }

    #[derive(Debug, Clone, Copy)]
    pub struct User;
    impl AggregateType for User {
        type Id = String;
        type Event = UserDomainEvents;
        type State = UserState;
    }

    #[test]
    fn aggregate_root_new() {
        let mut root = AggregateRoot::<User>::new(String::from("id"));
        assert_eq!(root.id(), "id");
        assert_eq!(root.version(), 0);
        assert_eq!(root.state(), &UserState::default());
        assert_eq!(root.current_version(), 0);
        assert_eq!(root.take_uncommitted_events(), Vec::new());
    }

    #[test]
    fn aggregate_root_load_from_history() {
        let timestamp = Utc::now();
        let history = get_user_events(Some(timestamp), EventOrderType::Ordered);
        let aggregate_root = AggregateRoot::<User>::load_from_history(String::from("id"), history);
        assert!(aggregate_root.is_ok());
        let mut aggregate_root = aggregate_root.unwrap();
        assert_eq!(aggregate_root.id(), "id");
        assert_eq!(aggregate_root.version(), 2);
        assert_eq!(
            aggregate_root.state(),
            &UserState::new(Some(String::from("joel@tixlys.com")), true, Some(timestamp))
        );
        assert_eq!(aggregate_root.current_version(), 2);
        assert_eq!(aggregate_root.take_uncommitted_events(), Vec::new());
    }

    #[test]
    fn aggregate_root_load_fail() {
        let timestamp = Utc::now();
        let history = get_user_events(Some(timestamp), EventOrderType::Ordered);
        let aggregate_root =
            AggregateRoot::<User>::load_from_history(String::from("wrong_id"), history);
        assert!(aggregate_root.is_err());
        let error = aggregate_root.unwrap_err();

        assert_eq!(
            error,
            AggregateLoadError::MismatchedAggregateId {
                expected_id: "wrong_id".to_string(),
                event_aggregate_id: "id".to_string()
            }
        );
    }

    #[tokio::test]
    async fn aggregate_root_execute_success() {
        let mut root = AggregateRoot::<User>::new(String::from("id"));
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };
        let handler = CreateUserHandler;
        let result = root.execute(create_user, &handler, &()).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result, "id");
    }

    #[tokio::test]
    async fn aggregate_root_domain_error() {
        let mut root = AggregateRoot::<User>::new(String::from("id"));
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "error@tixlys.com".to_string(),
        };
        let handler = CreateUserHandler;
        let result = root.execute(create_user, &handler, &()).await;
        assert!(result.is_err());
        let result = result.unwrap_err();
        assert_eq!(result, UserError::FailedToCreateUser);
    }
}
