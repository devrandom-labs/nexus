use super::{NonEmptyEvents, aggregate::AggregateType as AT};
use crate::{Command, DomainEvent};
use std::{boxed::Box, fmt::Debug, future::Future, pin::Pin};

/// # `CommandHandlerResponse<E, R>`
///
/// A container for the outcome of successfully processing a command by an [`AggregateCommandHandler`].
///
/// ## Type Parameters:
/// * `E`: The type of [`DomainEvent`] generated by the command handler.
/// * `R`: The type of the result returned by the command handler, specific to the command
///   (defined as `Command::Result`). This `R` must be `Debug + Send + Sync + 'static`.
///
/// This struct packages the `events` that need to be persisted and applied to the
/// aggregate's state, and the `result` that should be returned to the caller
/// of the command.
#[derive(Debug)]
pub struct CommandHandlerResponse<E, R>
where
    E: DomainEvent,
    R: Debug + Send + Sync + 'static,
{
    /// A vector of domain events that were generated as a result of the command.
    /// These events capture the state changes that occurred.
    pub events: NonEmptyEvents<E, 1>,

    /// The specific result value from processing the command (e.g., an ID, a status).
    pub result: R,
}

/// # `AggregateCommandHandler<C, Services>`
///
/// A trait for implementing the business logic that processes a specific command (`C`)
/// against an aggregate's state.
///
/// Command handlers are central to the command-processing pipeline in a CQRS system.
/// They encapsulate the decision-making, validation, and event generation logic.
///
/// Implementations of this trait are typically specific to one type of aggregate
/// (defined by `Self::AggregateType`) and one type of command (`C`).
///
/// ## Type Parameters:
/// * `C`: The type of the command this handler can process. It must implement [`Command`].
/// * `Services`: A type representing any external dependencies (services) that this
///   command handler might need to perform its logic (e.g., for validation,
///   external lookups, sending notifications via interfaces). This type must be
///   `Send + Sync + ?Sized`. The `?Sized` allows for the use of trait objects
///   (e.g., `dyn MyServiceTrait`) if dynamic dispatch is required for services,
///   or concrete types for static dispatch.
///
/// This trait requires `Send + Sync` to ensure handlers can be used safely across threads.
pub trait AggregateCommandHandler<C, Services>: Send + Sync
where
    C: Command,
    Services: Send + Sync + ?Sized,
{
    /// ## Associated Type: `AggregateType`
    /// Specifies the kind of aggregate (which must implement [`AT`](super::aggregate::AggregateType))
    /// this command handler operates on. This links the handler to the aggregate's
    /// specific `State` and `Event` types.
    type AggregateType: AT;

    /// ## Method: `handle`
    /// Asynchronously processes the given `command` using the current aggregate `state`
    /// and any provided `services`.
    ///
    /// ### Parameters:
    /// * `state`: A reference to the current state of the aggregate
    ///   (`<Self::AggregateType as AT>::State`). The handler uses this state to make
    ///   decisions but should not mutate it directly. Mutations occur by generating events.
    /// * `command`: The command instance to be processed.
    /// * `services`: A reference to the external services bundle.
    ///
    /// ### Returns:
    /// A `Pin<Box<dyn Future<Output = Result<CommandHandlerResponse<...>, C::Error>> + Send + 'a>>`.
    /// This signifies an asynchronous operation that will eventually produce:
    /// * `Ok(CommandHandlerResponse)`: On success, containing the generated domain events
    ///   (`Vec<<Self::AggregateType as AT>::Event>`) and the command's specific result (`C::Result`).
    /// * `Err(C::Error)`: On failure, containing the command's specific error type.
    ///
    /// The `'a` lifetime ensures that the returned future does not outlive the references
    /// to `self`, `state`, and `services`.
    #[allow(clippy::type_complexity)]
    fn handle<'a>(
        &'a self,
        state: &'a <Self::AggregateType as AT>::State,
        command: C,
        services: &'a Services,
    ) -> Pin<
        Box<
            dyn Future<
                    Output = Result<
                        CommandHandlerResponse<<Self::AggregateType as AT>::Event, C::Result>,
                        C::Error,
                    >,
                > + Send
                + 'a,
        >,
    >;
}

#[cfg(test)]
pub mod test {
    use super::super::test::{
        CreateUser, CreateUserAndActivate, CreateUserHandler, CreateUserHandlerWithService,
        CreateUserWithStateCheck, DynTestService, MockDynTestService, ProcessWithDynServiceHandler,
        SomeService, UserDomainEvents, UserError, UserState,
    };
    use super::AggregateCommandHandler;
    use crate::command::test::{ActivateUser, ActivateUserHandler};

    #[tokio::test]
    async fn should_execute_handler_successfully_returning_events_and_result() {
        let state = UserState::default();

        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };

        let handler = CreateUserHandler;
        let result = handler.handle(&state, create_user.clone(), &()).await;

        assert!(result.is_ok());
        let result = result.unwrap();

        // Convert SmallVec to a regular slice or Vec to inspect elements
        let events_vec = result.events.into_small_vec();
        assert_eq!(events_vec.len(), 1, "Expected exactly one event");

        // Perform a pattern match on the first event
        if let Some(UserDomainEvents::UserCreated {
            id: event_id,
            email: event_email,
            timestamp: _,
        }) = events_vec.first()
        {
            // Assertions for command data in event
            assert_eq!(
                event_id, &create_user.user_id,
                "Event ID should match command user_id"
            );
            assert_eq!(
                event_email, &create_user.email,
                "Event email should match command email"
            );
        } else {
            panic!("Expected UserCreated event, but found another event type or no event.");
        }

        // Assertions for command data in result
        assert_eq!(result.result, create_user.user_id);
    }

    #[tokio::test]
    async fn should_fail_execution_when_handler_logic_encounters_error() {
        let state = UserState::default();
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "error@tixlys.com".to_string(),
        };

        let handler = CreateUserHandler;
        let result = handler.handle(&state, create_user, &()).await;
        assert!(result.is_err());
        let result = result.unwrap_err();
        assert_eq!(result, UserError::FailedToCreateUser);
    }

    #[tokio::test]
    async fn should_succeed_when_state_satisfies_handler_preconditions() {
        let state = UserState::default();
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };

        let handler = CreateUserWithStateCheck;
        let result = handler.handle(&state, create_user, &()).await;
        assert!(result.is_ok());
        let result = result.unwrap();

        assert!(matches!(
            result.events.into_small_vec().as_slice(),
            [UserDomainEvents::UserCreated { .. }]
        ));
        assert_eq!(result.result, "id".to_owned());
    }

    #[tokio::test]
    async fn should_fail_when_state_does_not_satisfy_handler_preconditions() {
        let state = UserState::default();
        let activate_user = ActivateUser {
            user_id: "id".to_string(),
        };
        let handler = ActivateUserHandler;
        let result = handler.handle(&state, activate_user, &()).await;
        assert!(result.is_err());
        let result = result.unwrap_err();
        assert_eq!(result, UserError::FailedToActivate);
    }

    #[tokio::test]
    async fn should_correctly_use_concrete_service_to_influence_outcome() {
        let state = UserState::default();
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };

        let service = SomeService {
            name: "some_service".to_string(),
        };
        let handler = CreateUserHandlerWithService;
        let result = handler.handle(&state, create_user, &service).await;
        assert!(result.is_ok());
        let result = result.unwrap();

        assert!(matches!(
            result.events.into_small_vec().as_slice(),
            [UserDomainEvents::UserCreated { .. }]
        ));
        assert_eq!(result.result, "some_service".to_owned());
    }

    #[tokio::test]
    async fn should_correctly_use_dyn_trait_service_to_influence_outcome() {
        let state = UserState::default(); // Assuming UserState is appropriate
        let command = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };

        let mock_service_impl = MockDynTestService {
            prefix: "DynServicePrefix".to_string(),
            suffix_to_add: Some("ProcessedData".to_string()),
        };

        let handler = ProcessWithDynServiceHandler;

        // 2. Create a trait object for the service
        // This is the key part: `services` will be of type `&(dyn DynTestService + 'a)`
        let dyn_services: &dyn DynTestService = &mock_service_impl;

        // 3. Execute the handler with the trait object
        let result = handler.handle(&state, command.clone(), dyn_services).await;

        // 4. Assert the outcome
        assert!(result.is_ok(), "Handler failed: {:?}", result.err());
        let response = result.unwrap();

        // Assert that the service influenced the result
        let expected_result_string = mock_service_impl.process(&command.email);
        assert_eq!(
            response.result, expected_result_string,
            "The result string from the handler should match the service's processed output."
        );

        // Assert the event (confirming it's the placeholder UserActivated with correct id)
        let events_vec = response.events.into_small_vec();
        assert_eq!(events_vec.len(), 1, "Expected exactly one event");

        match events_vec.first() {
            Some(UserDomainEvents::UserCreated { id, .. }) => {
                assert_eq!(
                    id, &command.user_id,
                    "Event ID should match command item_id"
                );
            }
            _ => panic!("Expected UserCreated event, but found something else or no event."),
        }
    }

    #[tokio::test]
    async fn should_emit_multiple_distinct_events_when_logic_requires() {
        let state = UserState::default();
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };

        let handler = CreateUserAndActivate;
        let result = handler.handle(&state, create_user, &()).await;
        assert!(result.is_ok());
        let result = result.unwrap();

        assert!(matches!(
            result.events.into_small_vec().as_slice(),
            [
                UserDomainEvents::UserCreated { .. },
                UserDomainEvents::UserActivated { .. }
            ]
        ));
        assert_eq!(result.result, "id".to_owned());
    }
}
