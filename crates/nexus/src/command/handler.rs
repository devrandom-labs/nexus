use super::{NonEmptyEvents, aggregate::AggregateType as AT};
use crate::{Command, DomainEvent};
use std::{boxed::Box, fmt::Debug, future::Future, pin::Pin};

/// # `CommandHandlerResponse<E, R>`
///
/// A container for the outcome of successfully processing a command by an [`AggregateCommandHandler`].
///
/// ## Type Parameters:
/// * `E`: The type of [`DomainEvent`] generated by the command handler.
/// * `R`: The type of the result returned by the command handler, specific to the command
///   (defined as `Command::Result`). This `R` must be `Debug + Send + Sync + 'static`.
///
/// This struct packages the `events` that need to be persisted and applied to the
/// aggregate's state, and the `result` that should be returned to the caller
/// of the command.
#[derive(Debug)]
pub struct CommandHandlerResponse<E, R>
where
    E: DomainEvent,
    R: Debug + Send + Sync + 'static,
{
    /// A vector of domain events that were generated as a result of the command.
    /// These events capture the state changes that occurred.
    pub events: NonEmptyEvents<E, 1>,

    /// The specific result value from processing the command (e.g., an ID, a status).
    pub result: R,
}

/// # `AggregateCommandHandler<C, Services>`
///
/// A trait for implementing the business logic that processes a specific command (`C`)
/// against an aggregate's state.
///
/// Command handlers are central to the command-processing pipeline in a CQRS system.
/// They encapsulate the decision-making, validation, and event generation logic.
///
/// Implementations of this trait are typically specific to one type of aggregate
/// (defined by `Self::AggregateType`) and one type of command (`C`).
///
/// ## Type Parameters:
/// * `C`: The type of the command this handler can process. It must implement [`Command`].
/// * `Services`: A type representing any external dependencies (services) that this
///   command handler might need to perform its logic (e.g., for validation,
///   external lookups, sending notifications via interfaces). This type must be
///   `Send + Sync + ?Sized`. The `?Sized` allows for the use of trait objects
///   (e.g., `dyn MyServiceTrait`) if dynamic dispatch is required for services,
///   or concrete types for static dispatch.
///
/// This trait requires `Send + Sync` to ensure handlers can be used safely across threads.
pub trait AggregateCommandHandler<C, Services>: Send + Sync
where
    C: Command,
    Services: Send + Sync + ?Sized,
{
    /// ## Associated Type: `AggregateType`
    /// Specifies the kind of aggregate (which must implement [`AT`](super::aggregate::AggregateType))
    /// this command handler operates on. This links the handler to the aggregate's
    /// specific `State` and `Event` types.
    type AggregateType: AT;

    /// ## Method: `handle`
    /// Asynchronously processes the given `command` using the current aggregate `state`
    /// and any provided `services`.
    ///
    /// ### Parameters:
    /// * `state`: A reference to the current state of the aggregate
    ///   (`<Self::AggregateType as AT>::State`). The handler uses this state to make
    ///   decisions but should not mutate it directly. Mutations occur by generating events.
    /// * `command`: The command instance to be processed.
    /// * `services`: A reference to the external services bundle.
    ///
    /// ### Returns:
    /// A `Pin<Box<dyn Future<Output = Result<CommandHandlerResponse<...>, C::Error>> + Send + 'a>>`.
    /// This signifies an asynchronous operation that will eventually produce:
    /// * `Ok(CommandHandlerResponse)`: On success, containing the generated domain events
    ///   (`Vec<<Self::AggregateType as AT>::Event>`) and the command's specific result (`C::Result`).
    /// * `Err(C::Error)`: On failure, containing the command's specific error type.
    ///
    /// The `'a` lifetime ensures that the returned future does not outlive the references
    /// to `self`, `state`, and `services`.
    #[allow(clippy::type_complexity)]
    fn handle<'a>(
        &'a self,
        state: &'a <Self::AggregateType as AT>::State,
        command: C,
        services: &'a Services,
    ) -> Pin<
        Box<
            dyn Future<
                    Output = Result<
                        CommandHandlerResponse<<Self::AggregateType as AT>::Event, C::Result>,
                        C::Error,
                    >,
                > + Send
                + 'a,
        >,
    >;
}

#[cfg(test)]
pub mod test {
    use super::super::test::{
        CreateUser, CreateUserHandler, UserDomainEvents, UserError, UserState,
    };
    use super::AggregateCommandHandler;

    #[tokio::test]
    async fn should_execute_handler_successfully_returning_events_and_result() {
        let state = UserState::default();

        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };

        let handler = CreateUserHandler;
        let result = handler.handle(&state, create_user, &()).await;

        assert!(result.is_ok());
        let result = result.unwrap();

        assert!(matches!(
            result.events.into_small_vec().as_slice(),
            [UserDomainEvents::UserCreated { .. }]
        ));
        assert_eq!(result.result, "id");
    }

    #[tokio::test]
    async fn should_fail_execution_when_handler_logic_encounters_error() {
        let state = UserState::default();
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "error@tixlys.com".to_string(),
        };

        let handler = CreateUserHandler;
        let result = handler.handle(&state, create_user, &()).await;
        assert!(result.is_err());
        let result = result.unwrap_err();
        assert_eq!(result, UserError::FailedToCreateUser);
    }

    #[tokio::test]
    async fn should_succeed_when_state_satisfies_handler_preconditions() {}
    #[tokio::test]
    async fn should_fail_when_state_does_not_satisfy_handler_preconditions() {}
    #[tokio::test]
    async fn should_correctly_use_concrete_service_to_influence_outcome() {}
    #[tokio::test]
    async fn should_correctly_use_dyn_trait_service_to_influence_outcome() {}
    #[tokio::test]
    async fn should_emit_single_event_as_dictated_by_handler_logic() {}
    #[tokio::test]
    async fn should_emit_multiple_distinct_events_when_logic_requires() {}
    #[tokio::test]
    async fn should_accurately_reflect_command_data_in_emitted_event() {}
    #[tokio::test]
    async fn should_accurately_reflect_command_data_in_handler_result() {}
}
