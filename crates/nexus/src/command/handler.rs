use crate::{
    domain::{AggregateType as AT, Command, DomainEvent},
    infra::events::Events,
};
use std::{boxed::Box, fmt::Debug, future::Future, pin::Pin};

/// # `CommandHandlerResponse<E, R>`
///
/// A container for the outcome of successfully processing a command by an [`AggregateCommandHandler`].
///
/// ## Type Parameters:
/// * `E`: The type of [`DomainEvent`] generated by the command handler.
/// * `R`: The type of the result returned by the command handler, specific to the command
///   (defined as `Command::Result`). This `R` must be `Debug + Send + Sync + 'static`.
///
/// This struct packages the `events` that need to be persisted and applied to the
/// aggregate's state, and the `result` that should be returned to the caller
/// of the command.
#[derive(Debug)]
pub struct CommandHandlerResponse<E, R>
where
    E: DomainEvent,
    R: Debug + Send + Sync + 'static,
{
    /// A vector of domain events that were generated as a result of the command.
    /// These events capture the state changes that occurred.
    pub events: Events<E>,

    /// The specific result value from processing the command (e.g., an ID, a status).
    pub result: R,
}

/// # `AggregateCommandHandler<C, Services>`
///
/// A trait for implementing the business logic that processes a specific command (`C`)
/// against an aggregate's state.
///
/// Command handlers are central to the command-processing pipeline in a CQRS system.
/// They encapsulate the decision-making, validation, and event generation logic.
///
/// Implementations of this trait are typically specific to one type of aggregate
/// (defined by `Self::AggregateType`) and one type of command (`C`).
///
/// ## Type Parameters:
/// * `C`: The type of the command this handler can process. It must implement [`Command`].
/// * `Services`: A type representing any external dependencies (services) that this
///   command handler might need to perform its logic (e.g., for validation,
///   external lookups, sending notifications via interfaces). This type must be
///   `Send + Sync + ?Sized`. The `?Sized` allows for the use of trait objects
///   (e.g., `dyn MyServiceTrait`) if dynamic dispatch is required for services,
///   or concrete types for static dispatch.
///
/// This trait requires `Send + Sync` to ensure handlers can be used safely across threads.
pub trait AggregateCommandHandler<C, Services>: Send + Sync
where
    C: Command,
    Services: Send + Sync + ?Sized,
{
    /// ## Associated Type: `AggregateType`
    /// Specifies the kind of aggregate (which must implement [`AT`](super::aggregate::AggregateType))
    /// this command handler operates on. This links the handler to the aggregate's
    /// specific `State` and `Event` types.
    type AggregateType: AT;

    /// ## Method: `handle`
    /// Asynchronously processes the given `command` using the current aggregate `state`
    /// and any provided `services`.
    ///
    /// ### Parameters:
    /// * `state`: A reference to the current state of the aggregate
    ///   (`<Self::AggregateType as AT>::State`). The handler uses this state to make
    ///   decisions but should not mutate it directly. Mutations occur by generating events.
    /// * `command`: The command instance to be processed.
    /// * `services`: A reference to the external services bundle.
    ///
    /// ### Returns:
    /// A `Pin<Box<dyn Future<Output = Result<CommandHandlerResponse<...>, C::Error>> + Send + 'a>>`.
    /// This signifies an asynchronous operation that will eventually produce:
    /// * `Ok(CommandHandlerResponse)`: On success, containing the generated domain events
    ///   (`Vec<<Self::AggregateType as AT>::Event>`) and the command's specific result (`C::Result`).
    /// * `Err(C::Error)`: On failure, containing the command's specific error type.
    ///
    /// The `'a` lifetime ensures that the returned future does not outlive the references
    /// to `self`, `state`, and `services`.
    #[allow(clippy::type_complexity)]
    fn handle<'a>(
        &'a self,
        state: &'a <Self::AggregateType as AT>::State,
        command: C,
        services: &'a Services,
    ) -> Pin<
        Box<
            dyn Future<
                    Output = Result<
                        CommandHandlerResponse<<Self::AggregateType as AT>::Event, C::Result>,
                        C::Error,
                    >,
                > + Send
                + 'a,
        >,
    >;
}
