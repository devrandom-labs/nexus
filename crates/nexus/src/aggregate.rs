use super::{Command, DomainEvent};
use std::{boxed::Box, fmt::Debug, hash::Hash, pin::Pin};

/// Represents the actual state data of an aggregate.
/// It's rebuilt by applying events and must know how to apply them.
pub trait AggregateState: Default + Send + Sync + Debug + 'static {
    /// Specific type of Domain Event this state reacts to.
    type Event: DomainEvent;

    /// Mutates the state based on a receieved event.
    /// This is the core of state reconstruction in Event Sourcing.
    /// It should *NOT* contain complex logic or validation. just state mutation.
    fn apply(&mut self, event: &Self::Event);
}

/// Marker trait to define the component types of a specific Aggregate kind.
/// Implement this on a distinct type (often a unit struct) for each aggregate.
pub trait AggregateType: Send + Sync + Debug + Copy + Clone + 'static {
    /// The type used to uniquely identify this aggregate instance.
    type Id: Send + Sync + Debug + Eq + Hash + Clone + 'static;
    /// The specific type of Domain Event associated with this aggregate.
    type Event: DomainEvent + PartialEq;
    /// The specific type representing the internal state data.
    /// Crucially links the State's Event type to the AggregateType's Event type.
    type State: AggregateState<Event = Self::Event>;
}

/// Provides a standard interface for accessing aggregate properties.
/// Implemented by `AggregateRoot`.
pub trait Aggregate: Send + Sync + 'static {
    type Id: Send + Sync + Debug + Eq + Hash + Clone + 'static;
    type Event: DomainEvent + PartialEq;
    type State: AggregateState<Event = Self::Event>;

    fn id(&self) -> &Self::Id;
    /// Returns the version loaded from the store (basis for concurrency checks).
    fn version(&self) -> u64;
    fn state(&self) -> &Self::State;
    /// Takes ownership of newly generated events for saving.
    fn take_uncommitted_events(&mut self) -> Vec<Self::Event>;
}

pub type CommandHandlerResult<State, C> =
    Result<Vec<<State as AggregateState>::Event>, <C as Command>::Error>;

pub type CommandHandlerFuture<'a, State, C> =
    Pin<Box<dyn Future<Output = CommandHandlerResult<State, C>> + Send + 'a>>;

/// Encapsulates the pure domain logic for a specific command/state combination.
/// Implement this for each command that modifies an aggregate.
pub trait AggregateCommandHandler<State, C, Services>: Send + Sync
where
    State: AggregateState,
    C: Command,
    Services: Send + Sync + ?Sized,
{
    /// Processes the command against the current state using optional services.
    /// Returns a list of events if successful, or the command-specific domain error.
    fn handle<'a>(
        &'a self,
        state: &'a State,
        command: C,
        services: &'a Services,
    ) -> CommandHandlerFuture<'a, State, C>;

    /// Determines the result (`C::Result`) to return upon successful handling.
    fn derive_result(&self) -> C::Result;
}

/// Concrete implementation managing an aggregate's state based on events.
/// Generic over the aggregate definition provided by `AT: AggregateType`.
#[derive(Debug)]
pub struct AggregateRoot<AT: AggregateType> {
    id: AT::Id,
    state: AT::State,
    /// The version loaded from the event store (number of events historically applied).
    version: u64,
    /// Events generated by the last command execution, not yet persisted.
    uncommitted_events: Vec<AT::Event>,
}

impl<AT> Aggregate for AggregateRoot<AT>
where
    AT: AggregateType,
{
    type Id = AT::Id;
    type Event = AT::Event;
    type State = AT::State;

    fn id(&self) -> &Self::Id {
        &self.id
    }

    fn state(&self) -> &Self::State {
        &self.state
    }

    fn version(&self) -> u64 {
        self.version
    }

    fn take_uncommitted_events(&mut self) -> Vec<Self::Event> {
        std::mem::take(&mut self.uncommitted_events)
    }
}

impl<AT> AggregateRoot<AT>
where
    AT: AggregateType,
{
    /// Creates a new aggregate instance with default state and version 0.
    pub fn new(id: AT::Id) -> Self {
        Self {
            id,
            state: AT::State::default(),
            version: 0,
            uncommitted_events: Vec::new(),
        }
    }

    /// Rehydrates aggregate state by applying historical events.
    pub fn load_from_history(id: AT::Id, history: impl IntoIterator<Item = AT::Event>) -> Self {
        let mut state = AT::State::default();
        let mut version = 0u64;

        for event in history {
            state.apply(&event);
            version += 1;
        }

        Self {
            id,
            state,
            version,
            uncommitted_events: Vec::new(),
        }
    }

    /// Gets the effective current version, including uncommitted events.
    /// Useful for repositories implementing optimistic concurrency checks.
    pub fn current_version(&self) -> u64 {
        self.version + self.uncommitted_events.len() as u64
    }

    pub async fn execute<C, Handler, Services>(
        &mut self,
        command: C,
        handler: &Handler,
        services: &Services,
    ) -> Result<C::Result, C::Error>
    where
        C: Command,
        Handler: AggregateCommandHandler<AT::State, C, Services>,
        Services: Send + Sync + ?Sized,
    {
        let generated_events = handler.handle(&self.state, command, services).await?;
        for event in &generated_events {
            self.state.apply(event);
        }
        self.uncommitted_events.extend(generated_events);
        let result = handler.derive_result();
        Ok(result)
    }
}

// // --- Example Definitions (User Aggregate) ---

// // Marker type for User Aggregate
// #[derive(Debug, Clone, Copy)]
// pub struct UserAggregateType;
// impl AggregateType for UserAggregateType {
//     type Id = String;
//     type State = UserState;
//     type Event = UserEvent;
// }

// // User State
// #[derive(Debug, Clone, Default)]
// pub struct UserState {
//     email: Option<String>,
//     is_active: bool,
//     created_at: Option<chrono::DateTime<chrono::Utc>>,
// }

// // User Events Enum
// #[derive(Debug, Clone, PartialEq, Serialize, DeserializeOwned)]
// pub enum UserEvent {
//     UserCreated { email: String, timestamp: chrono::DateTime<chrono::Utc> },
//     UserActivated,
// }
// impl Message for UserEvent {}
// impl DomainEvent for UserEvent {}

// // State evolution logic
// impl AggregateState for UserState {
//     type Event = UserEvent;
//     fn apply(&mut self, event: &Self::Event) {
//         match event {
//             UserEvent::UserCreated { email, timestamp } => {
//                 if self.created_at.is_none() { // Idempotency check (optional but good)
//                     self.email = Some(email.clone());
//                     self.created_at = Some(*timestamp);
//                     self.is_active = false;
//                 }
//             }
//             UserEvent::UserActivated => {
//                 self.is_active = true;
//             }
//         }
//     }
// }

// // Example Command, Error, Logic (Create User)
// #[derive(Debug)] pub struct CreateUserCmd { pub user_id: String, pub email: String }
// impl Message for CreateUserCmd {}
// #[derive(Error, Debug)] #[error("User already exists: {0}")] pub struct UserExistsError(String);
// impl Command for CreateUserCmd { type Result = (); type Error = UserExistsError; }

// pub struct CreateUserLogic; // The logic handler struct
// pub struct UserServices { /* Dependencies like email checker */ } // Placeholder for services

// impl AggregateCommandHandler<UserState, CreateUserCmd, UserServices> for CreateUserLogic {
//     fn handle(&self, state: &UserState, command: CreateUserCmd, _services: &UserServices)
//         -> Result<Vec<UserEvent>, UserExistsError>
//     {
//         if state.created_at.is_some() { // Check business rule using current state
//             Err(UserExistsError(command.user_id))
//         } else {
//             // Potentially use _services here
//             Ok(vec![UserEvent::UserCreated {
//                 email: command.email,
//                 timestamp: chrono::Utc::now(), // Generate event data
//             }])
//         }
//     }
//     fn derive_result(&self) -> <CreateUserCmd as Command>::Result { () } // Simple Ack
// }
