use super::{
    Aggregate, AggregateCommandHandler, AggregateState, AggregateType,
    command_handler::CommandHandlerResponse,
};
use crate::{Command, DomainEvent};
use std::fmt::Debug;
use thiserror::Error as ThisError;

#[derive(Debug, ThisError, PartialEq)]
pub enum AggregateLoadError<Id>
where
    Id: Debug,
{
    #[error(
        "Event integrity error: Loaded event with mismatched aggregate ID. Expected '{expected_id:?}', found in event: '{event_aggregate_id:?}'."
    )]
    MismatchedAggregateId {
        expected_id: Id,
        event_aggregate_id: Id,
    },
}

/// Concrete implementation managing an aggregate's state based on events.
/// Generic over the aggregate definition provided by `AT: AggregateType`.
#[derive(Debug)]
pub struct AggregateRoot<AT: AggregateType> {
    id: AT::Id,
    state: AT::State,
    /// The version loaded from the event store (number of events historically applied).
    version: u64,
    /// Events generated by the last command execution, not yet persisted.
    uncommitted_events: Vec<AT::Event>,
}

impl<AT> Aggregate for AggregateRoot<AT>
where
    AT: AggregateType,
{
    type Id = AT::Id;
    type Event = AT::Event;
    type State = AT::State;

    fn id(&self) -> &Self::Id {
        &self.id
    }

    fn state(&self) -> &Self::State {
        &self.state
    }

    fn version(&self) -> u64 {
        self.version
    }

    fn take_uncommitted_events(&mut self) -> Vec<Self::Event> {
        std::mem::take(&mut self.uncommitted_events)
    }
}

impl<AT> AggregateRoot<AT>
where
    AT: AggregateType,
{
    /// Creates a new aggregate instance with default state and version 0.
    pub fn new(id: AT::Id) -> Self {
        Self {
            id,
            state: AT::State::default(),
            version: 0,
            uncommitted_events: Vec::new(),
        }
    }

    /// Rehydrates aggregate state by applying historical events.
    pub fn load_from_history(
        id: AT::Id,
        history: impl IntoIterator<Item = AT::Event>,
    ) -> Result<Self, AggregateLoadError<AT::Id>>
    where
        AT::Id: ToString,
    {
        let mut state = AT::State::default();
        let mut version = 0u64;

        for event in history {
            let event_id = event.aggregate_id();
            if event_id != &id {
                return Err(AggregateLoadError::MismatchedAggregateId {
                    expected_id: id,
                    event_aggregate_id: event_id.clone(),
                });
            }

            state.apply(&event);
            version += 1;
        }

        Ok(Self {
            id,
            state,
            version,
            uncommitted_events: Vec::new(),
        })
    }

    /// Gets the effective current version, including uncommitted events.
    /// Useful for repositories implementing optimistic concurrency checks.
    pub fn current_version(&self) -> u64 {
        self.version + self.uncommitted_events.len() as u64
    }

    pub async fn execute<C, Handler, Services>(
        &mut self,
        command: C,
        handler: &Handler,
        services: &Services,
    ) -> Result<C::Result, C::Error>
    where
        C: Command,
        Handler: AggregateCommandHandler<C, Services, AT = AT>,
        Services: Send + Sync + ?Sized,
    {
        let CommandHandlerResponse { events, result } =
            handler.handle(&self.state, command, services).await?;
        for event in &events {
            self.state.apply(event);
        }
        self.uncommitted_events.extend(events);
        Ok(result)
    }
}

#[cfg(test)]
pub mod test {
    use super::{Aggregate, AggregateRoot, AggregateType};
    use crate::aggregate::{
        aggregate_root::AggregateLoadError,
        command_handler::test::{CreateUser, CreateUserHandler, UserError},
        test::{EventOrderType, UserDomainEvents, UserState, get_user_events},
    };

    use chrono::Utc;

    #[derive(Debug, Clone, Copy)]
    pub struct User;
    impl AggregateType for User {
        type Id = String;
        type Event = UserDomainEvents;
        type State = UserState;
    }

    #[test]
    fn aggregate_root_new() {
        let mut root = AggregateRoot::<User>::new(String::from("id"));
        assert_eq!(root.id(), "id");
        assert_eq!(root.version(), 0);
        assert_eq!(root.state(), &UserState::default());
        assert_eq!(root.current_version(), 0);
        assert_eq!(root.take_uncommitted_events(), Vec::new());
    }

    #[test]
    fn aggregate_root_load_from_history() {
        let timestamp = Utc::now();
        let history = get_user_events(Some(timestamp), EventOrderType::Ordered);
        let aggregate_root = AggregateRoot::<User>::load_from_history(String::from("id"), history);
        assert!(aggregate_root.is_ok());
        let mut aggregate_root = aggregate_root.unwrap();
        assert_eq!(aggregate_root.id(), "id");
        assert_eq!(aggregate_root.version(), 2);
        assert_eq!(
            aggregate_root.state(),
            &UserState::new(Some(String::from("joel@tixlys.com")), true, Some(timestamp))
        );
        assert_eq!(aggregate_root.current_version(), 2);
        assert_eq!(aggregate_root.take_uncommitted_events(), Vec::new());
    }

    #[test]
    fn aggregate_root_load_fail() {
        let timestamp = Utc::now();
        let history = get_user_events(Some(timestamp), EventOrderType::Ordered);
        let aggregate_root =
            AggregateRoot::<User>::load_from_history(String::from("wrong_id"), history);
        assert!(aggregate_root.is_err());
        let error = aggregate_root.unwrap_err();

        assert_eq!(
            error,
            AggregateLoadError::MismatchedAggregateId {
                expected_id: "wrong_id".to_string(),
                event_aggregate_id: "id".to_string()
            }
        );
    }

    #[tokio::test]
    async fn aggregate_root_execute_success() {
        let mut root = AggregateRoot::<User>::new(String::from("id"));
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "joel@tixlys.com".to_string(),
        };
        let handler = CreateUserHandler;
        let result = root.execute(create_user, &handler, &()).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result, "id");
    }

    #[tokio::test]
    async fn aggregate_root_domain_error() {
        let mut root = AggregateRoot::<User>::new(String::from("id"));
        let create_user = CreateUser {
            user_id: "id".to_string(),
            email: "error@tixlys.com".to_string(),
        };
        let handler = CreateUserHandler;
        let result = root.execute(create_user, &handler, &()).await;
        assert!(result.is_err());
        let result = result.unwrap_err();
        assert_eq!(result, UserError::FailedToCreateUser);
    }
}
