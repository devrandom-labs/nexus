#+TITLE: ACR: Refactor Crate Error Handling to a Layered, Ergonomic Model
#+AUTHOR: Supreme Rust Architect
#+DATE: <2025-06-15>
#+PROPERTY: ACR_ID NEXUS-ACR-001
#+PROPERTY: STATUS Accepted
#+PROPERTY: CHAMPION Supreme Rust Architect
#+PROPERTY: CATEGORY API, DX, Refactoring
#+PROPERTY: RELATED_ISSUES
#+PROPERTY: VERSION_TARGET 0.2.0

* Executive Summary
  :PROPERTIES:
  :SECTION_TYPE: ExecutiveSummary
  :END:
  This change refactors the `nexus` crate's entire error handling strategy from a simplistic or tightly-coupled model to a sophisticated, layered "Hierarchical Facade." This new architecture improves developer experience by providing both clean, modular error definitions at each architectural layer and an ergonomic, top-level error type that facilitates simple, flat matching for common, actionable failures.

* 1. Change Description
  :PROPERTIES:
  :SECTION_TYPE: ChangeDescription
  :KEY_FEATURES: Hierarchical Errors, Error Promotion, Ergonomic Conversions, Co-located Errors
  :END:
  This proposal modifies the crate-wide error handling approach. The core change is to introduce a two-level error system:

  1.  *Co-located, Specific Errors*: Each primary component (e.g., `store`, `command::repository`) will define its own rich, public `Error` enum within its module. These enums will fully describe all possible failures for that specific component.

  2.  *Unifying, Top-Level Error*: A single, top-level `nexus::Error` enum will serve as the primary error type for high-level public APIs. This enum will act as a facade, providing variants that either "promote" common, actionable errors from the lower levels (like `ConnectionFailed`) or wrap the entire lower-level error enum for less common cases (e.g., `Store(store::Error)`).

  The implementation will leverage the `thiserror` crate and its `#[from]` attribute to create seamless, automatic conversions from specific errors into the top-level unifying error.

* 2. Background and Problem Statement
  :PROPERTIES:
  :SECTION_TYPE: ProblemStatement
  :PROBLEM_DOMAIN: Ergonomics, Maintainability, TypeSafety, Decoupling
  :CURRENT_BEHAVIOR: The prior error strategy was either a single, generic `RepositoryError` that coupled multiple layers, or an opaque `BoxError` wrapper.
  :LIMITATIONS_OF_CURRENT_BEHAVIOR: - A single "God Object" error enum creates tight coupling between architectural layers.
                                    - Opaque `BoxError` types provide poor ergonomics, forcing consumers to use `downcast` to inspect errors.
                                    - A purely hierarchical/wrapped error model leads to annoying, verbose nested `match` statements for the consumer.
  :END:
  The existing error handling approaches were not sufficient for a gold-standard library. A single, monolithic error enum couples unrelated components, making the library harder to maintain and evolve. Conversely, a purely wrapped error strategy, while decoupled, provides a poor developer experience (DX) for the consumer, who must perform verbose nested matches or type-casting to handle common, actionable errors. A change is needed to provide an API that is both architecturally pure and a pleasure to use.

* 3. Proposed Solution / Design
  :PROPERTIES:
  :SECTION_TYPE: ProposedSolution
  :SOLUTION_TYPE: NewModule, TraitModification, API Refactoring
  :CORE_COMPONENTS_AFFECTED: `EventStore`, `EventSourceRepository`, all error types
  :END:
  The proposed solution is a hybrid "Hierarchical Facade" error model.

  1.  **Co-located Error Definitions**:
      - `nexus::store::Error` will be a rich enum describing all possible storage failures (`ConnectionFailed`, `SourceNotFound`, `UniqueIdViolation`, etc.).
      - `nexus::command::repository::Error<Id>` will be a rich enum for repository-specific logical failures (`AggregateNotFound`, `Conflict`).






  2.  **Top-Level Unifying `nexus::Error`**:
      - This enum will be the primary return type for most public-facing methods in the `nexus` crate.
      - It will contain *promoted variants* for common, actionable errors. For example: `ConnectionFailed { source: BoxError }` and `ConcurrencyConflict { ... }`.
      - It will also contain *wrapper variants* for less common, layer-specific failures. For example: `Store(store::Error)` and `Repository(Box<repository::Error<Id>>)` .

  3.  **Ergonomic Conversion**:
      - `impl From<store::Error> for nexus::Error` will be implemented.
      - This implementation will act as a "triage" system, matching on the incoming `store::Error` and deciding whether to map it to a promoted top-level variant or wrap it in the `nexus::Error::Store` variant. This logic is internal to the crate.

* 4. Justification / Rationale
  :PROPERTIES:
  :SECTION_TYPE: Justification
  :PRIMARY_BENEFIT: ImprovedDeveloperExperience
  :ALIGNMENT_WITH_PRINCIPLES: ErgonomicPublicAPI, ArchitecturalPurity, CleanCode
  :END:
  This design is justified because it strikes the perfect balance between architectural purity and developer ergonomics.

  - *Enhanced Ergonomics*: It eliminates the need for nested `match` statements for all common, actionable errors, providing a flat, intuitive API surface for the consumer. The `#[from]` integration makes error propagation via the `?` operator seamless.
  - *Improved Maintainability & Decoupling*: By retaining the co-located, specific error enums, we ensure that each architectural layer remains modular and self-contained. The `store` module can evolve its errors without necessarily causing a breaking change in the top-level `nexus::Error`.
  - *Clarity*: The top-level `nexus::Error` acts as a "dashboard," immediately showing consumers the most critical failures they should handle, while still providing access to detailed, lower-level errors when needed for debugging.

* 5. Impact Analysis
  :PROPERTIES:
  :SECTION_TYPE: ImpactAnalysis
  :IMPACT_AREA_CODE: true
  :IMPACT_AREA_API_BREAKING: true
  :IMPACT_AREA_PERFORMANCE: Neutral
  :IMPACT_AREA_SECURITY: Neutral
  :IMPACT_AREA_TESTABILITY: Easier
  :IMPACT_AREA_DOCUMENTATION: Required
  :IMPACT_AREA_DEVELOPER_EXPERIENCE: Improved
  :END:
  - *On Crate Internals*: This is a significant refactoring affecting all traits and implementations that currently handle errors.
  - *On Users of the Crate (API Consumers)*: This is a breaking API change. Users will need to update their error handling logic to use the new `nexus::Error` enum and its variants. The change is expected to be straightforward and lead to cleaner consumer code.
  - *On Testability*: It becomes easier to write specific tests that assert a particular kind of framework error was returned.
  - *On Documentation*: Extensive documentation will be required to explain the new error handling philosophy, the structure of `nexus::Error`, and how to handle both promoted and wrapped errors.

* 6. Alternatives Considered
  :PROPERTIES:
  :SECTION_TYPE: AlternativesConsidered
  :NUMBER_OF_ALTERNATIVES: 2
  :END:
  - *Alternative 1: Single "God Object" Error Enum*
    - *Description*: Define one single, flat enum at the top level that contains every possible error variant from all layers.
    - *Reason for Not Choosing*: This approach leads to extremely tight coupling between architectural layers and creates a brittle, hard-to-maintain error type that must be modified any time a lower-level component's errors change.

  - *Alternative 2: Purely Wrapped Hierarchical Errors*
    - *Description*: Define co-located errors and have the top-level enum *only* contain wrapper variants (e.g., `Store(store::Error)`).
    - *Reason for Not Choosing*: While architecturally pure, this provides a poor developer experience, forcing consumers to write verbose and "annoying" nested `match` statements to handle common, actionable errors.

* 7. Decision
  :PROPERTIES:
  :SECTION_TYPE: Decision
  :DECISION_MAKER: Supreme Rust Architect
  :DECISION_DATE: <2025-06-15>
  :DECISION_OUTCOME: Accepted
  :END:
  The proposed "Hierarchical Facade" (co-location with error promotion) is accepted as the definitive error handling strategy for the `nexus` crate.

* 8. Action Items / Next Steps (If Accepted)
  :PROPERTIES:
  :SECTION_TYPE: ActionItems
  :END:
  1. [ ] Define the specific `store::Error` enum in the `nexus::store` module.
  2. [ ] Define the specific `command::repository::Error<Id>` enum.
  3. [ ] Define the top-level hybrid `nexus::Error` enum with promoted and wrapper variants.
  4. [ ] Implement the `From` traits to perform the triage/mapping from specific errors to the top-level error.
  5. [ ] Refactor the `EventStore` and `EventSourceRepository` trait signatures to return `Result<..., nexus::Error>`.
  6. [ ] Update all internal implementations (`SqliteEventStore`, etc.) to conform to the new error contracts.
  7. [ ] Create a new documentation page (`ERROR_HANDLING.md`) explaining the philosophy and usage patterns.

* 9. Notes / Discussion Points / Open Questions
  :PROPERTIES:
  :SECTION_TYPE: Discussion
  :END:
  The primary heuristic for deciding whether to promote an error to the top-level `nexus::Error` enum is: *"Is it highly likely that a consumer of the final, high-level API needs to write a specific `match` arm to handle this error programmatically?"* This principle should guide future modifications to the error hierarchy.
